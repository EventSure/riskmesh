// src/index.ts
import { decodeString } from "@switchboard-xyz/common";
import axios from "axios";
import bs58 from "bs58";
var LegacyCrossbarClient = class {
  crossbarUrl;
  verbose;
  // feed hash -> crossbar response (v1 format)
  feedCache = /* @__PURE__ */ new Map();
  constructor(crossbarUrl, verbose) {
    this.crossbarUrl = new URL(crossbarUrl).origin;
    this.verbose = !!verbose;
  }
  /**
   * GET /fetch/:feedHash
   * Fetch data from the crossbar using the provided feedHash (v1 legacy format)
   * @deprecated Use fetchOracleFeed() from @switchboard-xyz/common instead.
   * @param {string} feedHash - The hash of the feed to fetch data for
   * @returns {Promise<CrossbarFetchResponse>} - The data fetched from the crossbar
   */
  async fetch(feedHash) {
    try {
      const cached = this.feedCache.get(feedHash);
      if (cached) return cached;
      const response = await axios.get(`${this.crossbarUrl}/fetch/${feedHash}`).then((resp) => resp.data);
      this.feedCache.set(feedHash, response);
      return response;
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;
      const response = err.response;
      if (!response) throw err;
      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(`Bad Crossbar fetch status: ${response.status}`);
    }
  }
  /**
   * POST /store
   * Store oracle jobs on the crossbar, associated with a queue address (v1 legacy format)
   * @deprecated Use storeOracleFeed() from @switchboard-xyz/common instead.
   * @param {string} queueAddress - The address of the queue
   * @param {IOracleJob[]} jobs - The oracle jobs to store
   * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
   */
  async store(queueAddress, jobs) {
    try {
      const queue = decodeString(queueAddress);
      if (!queue) throw new Error(`Unable to parse queue: ${queueAddress}`);
      return await axios.post(
        `${this.crossbarUrl}/store`,
        { queue: bs58.encode(queue), jobs },
        { headers: { "Content-Type": "application/json" } }
      ).then((resp) => {
        if (resp.status === 200) return resp.data;
        throw new Error(`Bad Crossbar store response: ${resp.status}`);
      });
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;
      const response = err.response;
      if (!response) throw err;
      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(`Bad Crossbar store response: ${response.status}`);
    }
  }
  /**
   * GET /simulate/:feedHash
   * Simulate a feed using the legacy v1 endpoint
   * @deprecated Use simulateFeed() from @switchboard-xyz/common instead.
   * @param {string} feedHash - The hash of the feed to simulate
   * @param {boolean} [includeReceipts] - Whether to include receipts in the response
   * @returns {Promise<{ feedHash: string; results: string[]; receipts?: any[] }[]>} - The simulation results
   */
  async simulate(feedHash, includeReceipts) {
    try {
      const params = includeReceipts ? { includeReceipts: true } : {};
      return await axios.get(`${this.crossbarUrl}/simulate/${feedHash}`, { params }).then((resp) => resp.data);
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;
      const response = err.response;
      if (!response) throw err;
      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(`Bad Crossbar simulate status: ${response.status}`);
    }
  }
  /**
   * POST /gateways/fetch_signatures
   * Fetch signatures from oracles for a given set of jobs (v1 legacy format)
   * @deprecated Use fetchSignaturesConsensus() from @switchboard-xyz/common instead.
   * @param {FetchSignaturesRequest} request - The request parameters
   * @param {string} [network] - Optional network parameter (devnet/mainnet). Defaults to mainnet.
   * @returns {Promise<{ responses: FeedEvalResponse[]; failures: string[] }>} - Array of oracle signatures and results
   */
  async fetchSignatures(request, network) {
    try {
      return await axios.post(`${this.crossbarUrl}/gateways/fetch_signatures`, request, {
        params: { network }
      }).then((resp) => resp.data);
    } catch (err) {
      if (!axios.isAxiosError(err)) throw err;
      const response = err.response;
      if (!response) throw err;
      if (this.verbose) console.error(`${response.status}: ${response.data}`);
      throw new Error(
        `Bad Crossbar fetchOracleSignatures response: ${response.status}`
      );
    }
  }
};
export {
  LegacyCrossbarClient
};
